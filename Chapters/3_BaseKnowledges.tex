% ==========================================
% BASE KNOWLEDGES
% ==========================================

\newpage
\chapter{KIẾN THỨC NỀN}

\begin{concept}[15cm]
\textit{Nội dung chương này sẽ giới thiệu những kiến thức nền và các công nghệ được sử dụng trong đề tài. Để có thể giải quyết những thách thức như chương 2 đã nêu ra, cần nắm vững kiến thức nền tảng về hệ thống BE-PUM và lý thuyết về model checking, cũng như về công cụ NuSMV. Ngoài ra chương này cũng tập trung giới thiệu cụ thể về 13 kỹ thuật được hỗ trợ trong packer.}
\end{concept}

\section{Hệ thống BE-PUM}

\subsection{Kiến trúc của BE-PUM}

\hspace{0.5cm}Hệ thống BE-PUM xây dựng mô hình quá trình thực thi của một tập tin thực thi dựa trên kỹ thuật Dynamic symbolic execution. BE-PUM dựa trên thư viện mã nguồn mở Jackstab để dịch ngược mã nhị phân cho từng câu lệnh hợp ngữ tương ứng với từng câu lệnh thực thi của tập tin và chương trình Z3 để tìm ra đường đi nếu câu lệnh thực thi là một câu lệnh nhảy hoặc nhảy có điều kiện.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{bepum_architecture}
\caption{Kiến trúc của hệ thống BE-PUM}
\label{fig:BepumArchi}
\end{figure}

\hspace{0.5cm}Kiến trúc của hệ thống BE-PUM bao gồm 3 thành phần chính: symbolic execution, binary emulation và CFG storage. Hình \ref {fig:BepumArchi} mô tả kiến trúc của hệ thống BE-PUM. Trong đó, vai trò của các thành phần này như sau:

\begin{itemize}
\item{Single-step symbolic execution: sử dụng Jackstab để dịch ngược và chuyển đổi thành câu lệnh hợp ngữ tương ứng. Nếu câu lệnh hợp ngữ là câu lệnh chỉ tác động tới môi trường thực thi, cụ thể là các câu lệnh tính toán, câu lệnh ghi hoặc đọc trong bộ nhớ, bao gồm cả stack. Khi đó chỉ có môi trường thực thi được thay đổi và vị trí của câu lệnh tiếp theo chỉ được xác định bằng vị trí của câu lệnh hiện tại và kích thước câu lệnh. Nếu câu lệnh tiếp theo là câu lệnh điều khiển, cụ thể là các câu lệnh gọi hàm, câu lệnh trả về từ hàm, câu lệnh nhảy và câu lệnh nhảy có điều kiện, thì câu lệnh tiếp theo sẽ được tính toán thông qua dynamic symbolic execution.\\}
\item{
\begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{bepum_binary_emulation}
\caption{Thành phần Binary Emulation trong BE-PUM}
\label{fig:BepumBE}
\end{figure}
Binary emulation: là thành phần quan trọng trong tổng thể kiến trúc của BE-PUM. Để có thể xử lý một câu lệnh hợp ngữ, hệ thống BE-PUM sẽ giả lập các thành phần của hệ thống, cụ thể là mô hình bộ nhớ của BE-PUM, mô hình này bao gồm tập 9 cờ được sử dụng trong hệ thống (AF, CF, DF, IF, OF, PF, SF, TF, và ZF), tập 20 thanh ghi (EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP, CS, DS, ES, FS, GS, SS, EIP, EFLAGS và 8 thanh ghi debug DRO, DR1, DR2, DR3, DR4, DR5, DR6, DR7, DR8), tập các giá trị bộ nhớ được lưu trữ trong đó một phần của bộ nhớ cho stack được giới hạn bởi thanh ghi esp và thanh ghi ebp. Bộ nhớ được giả lập trong BE-PUM được lưu trữ dưới dạng từng byte một. Ngoài việc giả lập câu lệnh hợp ngữ, thì API cũng được giả lập thông qua sử dụng Java Native Access cho phép gọi trực tiếp từ các thư viện liên kết động, trong đó giá trị trả về của các API sẽ được lưu trữ trong các thanh ghi tương ứng. Đối với các API đặc biệt tác động trực tiếp đến môi trường thực, một sandbox sẽ được xây dựng cho quá trình xử lý các API này. Ngoài ra, các API được sử dụng như một phần của kỹ thuật anti-reversing, anti-debugging, giá trị trả về sẽ là một giá trị symbolic. Hình \ref {fig:BepumBE} mô tả các quá trình xử lý một câu lệnh thực thi trong hệ thống BE-PUM.\\
}
\item{CFG storage: được sử dụng để lưu trữ một CFG node và CFG edge sau khi được tính toán chính xác. CFG storage sẽ được sử dụng để xây dựng mô hình quá trình thực thi cuối cùng của tập tin được phân tích.}
\end{itemize}

\subsection{Mô hình của BE-PUM}
\hspace{0.5cm}Kết quả của quá trình phân tích một tập tin thực thi là một mô hình quá trình thực thi, mô hình được sinh ra bởi hệ thống BE-PUM được biểu diễn dưới dạng Control Flow Graph hay CFG của chương trình.\\

\hspace{0.5cm}Một CFG là một tập của các node và edge. Trong đó một node của CFG bao gồm địa chỉ của câu lệnh và câu lệnh hợp ngữ tại địa chỉ đó, một edge của CFG là cạnh nối giữa 2 node của CFG.

\begin{code}
\begin{lstlisting}[captionpos=b,caption={Ví dụ về một đoạn mã thực thi},label={lst:SampleExeASM},frame=single]
00401000  pushl 0x00401007
00401005  xor eax, eax
00401007  jne 0x00401005
0040100B  call ss:[esp]		
\end{lstlisting}
\end{code}

\hspace{0.5cm}Với đoạn mã \ref {lst:SampleExeASM}, quá trình phân tích trên hệ thống BE-PUM sẽ sinh ra được mô hình của đoạn mã thực thi hay CFG của chương trình thực thi trên như sau:

\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   	\node[cfgstate,align=center](s_1){0x00401000\\\ pushl 0x00401007}; 
   	\node[cfgstate,align=center](s_2)[below of=s_1]{0x00401005\\\ xorl \%eax, \%eax};
    \node[cfgstate,align=center](s_3)[below of=s_2]{0x00401007\\\ jne \%0x00401005};
   	\node[cfgstate,align=center](s_4)[below of=s_3]{0x0040100B\\\ call \%ss:[esp]};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge node {} (s_2)
    (s_2) edge node {} (s_3)
  	(s_3.east) edge [bend right=60] node {} (s_2.east)
    (s_3) edge node {} (s_4);	  
\end{tikzpicture}
\label{fig:SampleExeCFG}
\caption{CFG được sinh ra từ đoạn mã thực thi \ref {lst:SampleExeASM}}
\end{figure}

\subsection{Hạn chế của BE-PUM}

\hspace{0.5cm}Một số những hạn chế của hệ thống BE-PUM bao gồm:

\begin{itemize}
\item{Số lượng các câu lệnh hợp ngữ là rất lớn khoảng hơn 1000 câu lệnh và số lượng API là 4000. Tuy nhiên hiện tại BE-PUM chỉ hõ trợ được 200 câu lệnh và 400 API. Do đó đối với các malware hay packer sử dụng những câu lệnh hay API không được hỗ trợ, BE-PUM sẽ không thể phân tích tiếp tục được và do đó quá trình phân tích sẽ kết thúc.\\}
\item{Đối với những malware hay packer sử dụng những vòng lặp lớn hơn 1 tỷ lần thì quá trình phân tích trên BE-PUM sẽ kết thúc. Do đó khi gặp một vòng lặp với số lượng lớn thì quá trình phân tích sẽ tiếp tục được phân tích trên một đường thực thi khác.\\}
\item{Trong thực tế, trước khi thực thi tại entry point của chương trình, một số xử lý từ hệ điều hành sẽ được thực hiện qua đó tác động đến các giá trị thanh ghi, bộ nhớ và stack tại entry point. Do đó, khi quá trình phân tích bắt đầu, tại vị trí entry point, hệ thống BE-PUM sẽ mặc định thiết lập các giá trị mặc định cho stack bao gồm: địa chỉ chứa mã ASCII của tên tập tin, địa chỉ hàm xử lý exception của hệ thống, và giá trị trả về là một giá trị bất kì thuộc địa chỉ kernel.\\}
\item{Ngoài ra, các giá trị cờ cũng được thiết lập cụ thể như mô tả trong bảng \ref {table:BepumInitFlag}. Đối với các thanh ghi EAX, CS, DS, ES, FS, GS, SS, EFLAGS được thiết lập giá trị symbolic, các thanh ghi được thiết lập như mô tả trong bảng \ref {table:BepumInitReg}.
}
\end{itemize}

\begin{longtable}{ | m{2cm} | m{5cm} | }
\hline 
CF & False\\
\hline 
PF & True\\
\hline 
AF & False\\
\hline 
ZF & True\\
\hline 
SF & False\\
\hline 
TF & False\\
\hline 
DF & False\\
\hline 
OF & False\\
\hline 
IF & False\\
\hline
\caption{Các giá trị cờ được khởi tạo mặc định trong hệ thống BE-PUM}
\label{table:BepumInitFlag}
\end{longtable}

\begin{longtable}{ | m{5cm} | m{5cm} | }
\hline 
EIP, EDX & Địa chỉ entry point\\
\hline
ESP & Địa chỉ đỉnh của stack\\
\hline
EBP & Địa chỉ cơ sở của stack\\
\hline
ECX, EDI, ESI & 0\\
\hline
EBX & Địa chỉ PEB\\
\hline
\caption{Các giá trị thanh ghi được khởi tạo mặc định trong hệ thống BE-PUM}
\label{table:BepumInitReg}
\end{longtable}

\section{Model Checking và NuSMV}

\subsection{Model Checking}

\hspace{0.5cm}Model checking hay kiểm tra mô hình là một kỹ thuật tự động được sử dụng để kiểm tra một hệ thống tuần tự có số trạng thái hữu hạn bằng việc vét cạn toàn bộ không gian trạng thái của mô hình hệ thống. Bằng việc cung cấp một mô hình của hệ thống và một mô tả hành vi hệ thống cần kiểm tra dưới dạng biểu thức logic có yếu tố thời gian, phương pháp model checking có thể kết luận mô hình được kiểm tra có thoả mãn các tính chất được mô tả hay không. Hay nói một cách khác, với một mô hình hệ thống với số trạng thái hữu hạn $\mathcal{M}$ và một tính chất được biểu diễn dưới dạng hình thức $\phi$, phương pháp model checking sẽ kiểm tra nếu tính chất đó là thoả mãn với mô hình hệ thống: $\mathcal{M}\models\phi$. 

\subsection{Cấu trúc Kripke}

\hspace{0.5cm}Trong bước mô hình hoá được thực hiện trong phương pháp model checking sẽ chuyển đổi mô hình một hệ thống dưới dạng hình thức được sử dụng bởi một công cụ kiểm tra mô hình. Cấu trúc Kripke là một dạng của mô hình chuyển trạng thái biểu diễn hành vi của hệ thống trong suốt quá trình thời gian của hệ thống. Với AP là một tập của các mệnh đề nguyên tử, một cấu trúc Kripke trên tập AP $M = (S, S_0, R, L)$ được định nghĩa như sau:

\begin{itemize}
\item{$S$: tập hữu hạn các trạng thái.}
\item{$S_0 \subseteq S$: tập các trạng thái ban đầu.}
\item{$R \subseteq S \times S$: mối quan hệ chuyển trạng thái, theo đó với mọi trạng thái $s \in S$ luôn có trạng thái $s' \in S$ sao cho $R(s, s')$..}
\item{$L: S \rightarrow 2^{AP}$ là hàm xác định nhãn cho mỗi trạng thái với giá trị là các tập mệnh đề nguyên tử sao cho các mệnh đề đó là luôn đúng trong trạng thái đó.}
\end{itemize}

\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
   	\node[state,initial](s_1){$\lbrace p,q\rbrace$}; 
   	\node[state](s_2)[below left=of s_1]{$\lbrace q\rbrace$};
   	\node[state](s_3)[below right=of s_2]{$\lbrace p\rbrace$};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge [bend left] node {} (s_2)
    (s_2) edge [bend left] node {} (s_1)
    	  edge node {} (s_3)
    (s_3) edge [loop above] node {} ();
\end{tikzpicture}
\caption{Ví dụ về cấu trúc Kripke}
\label{fig:KripkeStruct}
\end{figure}

\hspace{0.5cm}Với mô hình \ref {fig:KripkeStruct}, cho $AP = \lbrace p,q\rbrace$. Một cấu trúc Kripke $M = (S, S_0, R, L)$ được xác định với: $S = \lbrace s_1, s_2, s_3 \rbrace$, $S_0 = \lbrace s_1 \rbrace$, $R = \lbrace (s_1, s_2), (s_2, s_1), (s_2, s_3), (s_3, s_3)$ và $L = \lbrace (s_1,\lbrace p,q \rbrace), (s_2,\lbrace q \rbrace), (s_3,\lbrace p \rbrace) \rbrace$	 

\subsection{Logic có yếu tố thời gian}

\hspace{0.5cm}Logic yếu tố thời gian là mở rộng của logic mệnh đề truyền thống với việc kết hợp các toán tử mô tả được hành vi của hệ thống theo thời gian. Logic yếu tố thời gian cho phép mô tả được các tính chất của hệ thống thực như tính correctness, reachability, safety, liveness, fairness. Các toán tử được sự dụng để mô tả các hành vi của hệ thống theo thời gian là Path quantifiers và Temporal operators trong đó.

\begin{itemize}
\item{Path quantifiers: trong một biểu thức logic yếu tố thời gian được sử dụng để mô tả cấu trúc nhánh trong một cây tính toán. Trong đó 2 path quantifiers được sử dụng trong một biểu thức logic tính toán cây là $A$, mô tả với mọi đường tính toán, và $E$, mô tả tồn tại một đường tính toán.\\}
\item{Temporal operators: trong một biểu thức logic yếu tố thời gian được sử dụng để mô tả tính chất của một đường tính toán trong một cây tính toán. Trong đó 4 temporal operators được sử dụng trong một biểu thức tính toán cây là $X, F, G, U$.}
\end{itemize}

\hspace{0.5cm}\textbf{Toán tử $X$("neXt")}: $X\varphi$ mô tả trạng thái tiếp theo trên một đường tính toán thoả mãn tính chất $\varphi$.
\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   	\node[state,initial,align=center,minimum size=0.5cm](s_0){$X\varphi$}; 
   	\node[state,align=center,minimum size=0.5cm,fill=gray](s_1)[right=of s_0]{$\varphi$};
   	\node[state,align=center,minimum size=0.5cm](s_2)[right=of s_1]{};
   	\node[state,align=center,minimum size=0.5cm](s_3)[right=of s_2]{};
   	\node (s_dots) [right=of s_3] {$\cdots$}; 
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_0) edge node {} (s_1)
    (s_1) edge node {} (s_2)
    (s_2) edge node {} (s_3)
    (s_3) edge node {} (s_dots);
\end{tikzpicture}
\caption{Toán tử thời gian $X$}
\label{fig:NextTemporal}
\end{figure}

\hspace{0.5cm}\textbf{Toán tử $F$("Finally")}: $F\varphi$ mô tả một trạng thái bất kì trong tương lai thoả mãn tính chất $\varphi$.
\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   	\node[state,initial,align=center,minimum size=0.5cm](s_0){$F\varphi$}; 
   	\node[state,align=center,minimum size=0.5cm](s_1)[right=of s_0]{};
   	\node[state,align=center,minimum size=0.5cm](s_2)[right=of s_1]{};
   	\node[state,align=center,minimum size=0.5cm,fill=gray](s_3)[right=of s_2]{$\varphi$};
   	\node (s_dots) [right=of s_3] {$\cdots$}; 
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_0) edge node {} (s_1)
    (s_1) edge node {} (s_2)
    (s_2) edge node {} (s_3)
    (s_3) edge node {} (s_dots);
\end{tikzpicture}
\caption{Toán tử thời gian $F$}
\label{fig:FutureTemporal}
\end{figure}

\hspace{0.5cm}\textbf{Toán tử $G$("Globally")}: $G\varphi$ mô tả tất cả trạng thái trong tương lai thoả mãn tính chất $\varphi$.
\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   	\node[state,initial,align=center,minimum size=0.5cm,fill=gray](s_0){$G\varphi,\varphi$}; 
   	\node[state,align=center,minimum size=0.5cm,fill=gray](s_1)[right=of s_0]{$\varphi$};
   	\node[state,align=center,minimum size=0.5cm,fill=gray](s_2)[right=of s_1]{$\varphi$};
   	\node[state,align=center,minimum size=0.5cm,fill=gray](s_3)[right=of s_2]{$\varphi$};
   	\node (s_dots) [right=of s_3] {$\cdots$}; 
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_0) edge node {} (s_1)
    (s_1) edge node {} (s_2)
    (s_2) edge node {} (s_3)
    (s_3) edge node {} (s_dots);
\end{tikzpicture}
\caption{Toán tử thời gian $G$}
\label{fig:GlobalTemporal}
\end{figure}


\hspace{0.5cm}\textbf{Toán tử $U$("Until")}: $\varphi_1U\varphi_2$ mô tả tính chất $\varphi_1$ thoả mãn trên tất cả trạng thái cho đến khi tính chất $\varphi_2$ thoả mãn.
\begin{figure}
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   	\node[state,initial,align=center,minimum size=0.5cm,fill=white!30!gray](s_0){$\varphi_1 U \varphi_2,\varphi_1$}; 
   	\node[state,align=center,minimum size=0.5cm,fill=white!30!gray](s_1)[right=of s_0]{$\varphi_1$};
   	\node[state,align=center,minimum size=0.5cm,fill=white!30!gray](s_2)[right=of s_1]{$\varphi_1$};
   	\node[state,align=center,minimum size=0.5cm,fill=gray](s_3)[right=of s_2]{$\varphi_2$};
   	\node (s_dots) [right=of s_3] {$\cdots$}; 
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_0) edge node {} (s_1)
    (s_1) edge node {} (s_2)
    (s_2) edge node {} (s_3)
    (s_3) edge node {} (s_dots);
\end{tikzpicture}
\caption{Toán tử thời gian $U$}
\label{fig:UntilTemporal}
\end{figure}

\subsection{CTL}

\hspace{0.5cm}\textbf{Syntax}
\begin{code}
\begin{lstlisting}[captionpos=b,caption={CTL Syntax},label={lst:CTLSyntax},frame=single,mathescape=true]
$\Phi \Coloneqq true\;|\;p\;|\;(\neg\Phi)\;|\;(\Phi_1\wedge\Phi_2)\;|\;A\phi\;|\;E\phi$
$\phi \Coloneqq X\Phi\;|\;\Phi_1 U\Phi_2$
\end{lstlisting}
\end{code}

\hspace{0.5cm}\textbf{Semantic}
\begin{center}
\resizebox{10cm}{!}{
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,on grid,auto] 
   	\node[state,initial,minimum size=0.5cm](s_1){}; 
   	\node[state, minimum size=0.5cm][below=of s_1](s_3){};
   	\node[state, minimum size=0.5cm][left=4cm of s_3](s_2){};
   	\node[state, minimum size=0.5cm][right=4cm of s_3,fill=red](s_4){};
   	\node[state, minimum size=0.5cm][below left=of s_2](s_5){};
   	\node[state, minimum size=0.5cm][below right=of s_2](s_6){};
   	\node[state, minimum size=0.5cm][below=1.06cm of s_3](s_7){};
   	\node[state, minimum size=0.5cm][below left=of s_4](s_8){};
	\node[state, minimum size=0.5cm][below right=of s_4](s_9){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_5](s_10){};
	\node[state, minimum size=0.5cm][below left=1.7cm of s_7](s_11){};
	\node[state, minimum size=0.5cm][below right=1.7cm of s_7](s_12){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_9](s_13){};
	\node[minimum size=0.5cm][below=of s_10](s_14){$\cdots$};
	\node[minimum size=0.5cm][below=of s_6](s_15){$\cdots$};
	\node[state, minimum size=0.5cm][below=of s_11](s_16){};
	\node[minimum size=0.5cm][below=of s_12](s_17){$\cdots$};
	\node[minimum size=0.5cm][below=of s_8](s_18){$\cdots$};
	\node[state,minimum size=0.5cm][below=of s_13](s_19){};
	\node[state,minimum size=0.5cm][below left=2.12cm of s_13](s_20){};
	\node[state,minimum size=0.5cm][below right=2.12cm of s_13](s_21){};
	\node[minimum size=0.5cm][below=of s_16](s_22){$\cdots$};
	\node[minimum size=0.5cm][below=of s_19](s_23){$\cdots$};
	\node[minimum size=0.5cm][below=of s_20](s_24){$\cdots$};
	\node[minimum size=0.5cm][below=of s_21](s_25){$\cdots$};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge node {} (s_2)
    	edge node {} (s_3)
    	edge node {} (s_4)
    (s_2) edge node {} (s_5)
    	edge node {} (s_6)
    (s_3) edge node {} (s_7)
    (s_4) edge node {} (s_8)
    	edge node {} (s_9)
    (s_5) edge node {} (s_10)
    (s_7) edge node {} (s_11)
    	edge node {} (s_12)
    (s_9) edge node {} (s_13)
    (s_11) edge node {} (s_16)
    (s_13) edge node {} (s_19)
    	edge node {} (s_20)
    	edge node {} (s_21);
\end{tikzpicture}
}\\
$M,s_0\models EX$\color{red}p
\end{center}

\begin{center}
\resizebox{10cm}{!}{
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,on grid,auto] 
   	\node[state,initial,minimum size=0.5cm,fill=red](s_1){}; 
   	\node[state, minimum size=0.5cm][below=of s_1,fill=red](s_3){};
   	\node[state, minimum size=0.5cm][left=4cm of s_3](s_2){};
   	\node[state, minimum size=0.5cm][right=4cm of s_3](s_4){};
   	\node[state, minimum size=0.5cm][below left=of s_2](s_5){};
   	\node[state, minimum size=0.5cm][below right=of s_2](s_6){};
   	\node[state, minimum size=0.5cm][below=1.06cm of s_3,fill=red](s_7){};
   	\node[state, minimum size=0.5cm][below left=of s_4](s_8){};
	\node[state, minimum size=0.5cm][below right=of s_4](s_9){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_5](s_10){};
	\node[state, minimum size=0.5cm][below left=1.7cm of s_7,fill=red](s_11){};
	\node[state, minimum size=0.5cm][below right=1.7cm of s_7](s_12){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_9](s_13){};
	\node[minimum size=0.5cm][below=of s_10](s_14){$\cdots$};
	\node[minimum size=0.5cm][below=of s_6](s_15){$\cdots$};
	\node[state, minimum size=0.5cm][below=of s_11,fill=red](s_16){};
	\node[minimum size=0.5cm][below=of s_12](s_17){$\cdots$};
	\node[minimum size=0.5cm][below=of s_8](s_18){$\cdots$};
	\node[state,minimum size=0.5cm][below=of s_13](s_19){};
	\node[state,minimum size=0.5cm][below left=2.12cm of s_13](s_20){};
	\node[state,minimum size=0.5cm][below right=2.12cm of s_13](s_21){};
	\node[minimum size=0.5cm][below=of s_16](s_22){$\cdots$};
	\node[minimum size=0.5cm][below=of s_19](s_23){$\cdots$};
	\node[minimum size=0.5cm][below=of s_20](s_24){$\cdots$};
	\node[minimum size=0.5cm][below=of s_21](s_25){$\cdots$};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge node {} (s_2)
    	edge node {} (s_3)
    	edge node {} (s_4)
    (s_2) edge node {} (s_5)
    	edge node {} (s_6)
    (s_3) edge node {} (s_7)
    (s_4) edge node {} (s_8)
    	edge node {} (s_9)
    (s_5) edge node {} (s_10)
    (s_7) edge node {} (s_11)
    	edge node {} (s_12)
    (s_9) edge node {} (s_13)
    (s_11) edge node {} (s_16)
    (s_13) edge node {} (s_19)
    	edge node {} (s_20)
    	edge node {} (s_21);
\end{tikzpicture}
}\\
$M,s_0\models EG$\color{red}p
\end{center}

\begin{center}
\resizebox{10cm}{!}{
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,on grid,auto] 
   	\node[state,initial,minimum size=0.5cm,fill=red](s_1){}; 
   	\node[state, minimum size=0.5cm][below=of s_1](s_3){};
   	\node[state, minimum size=0.5cm][left=4cm of s_3](s_2){};
   	\node[state, minimum size=0.5cm][right=4cm of s_3,fill=red](s_4){};
   	\node[state, minimum size=0.5cm][below left=of s_2](s_5){};
   	\node[state, minimum size=0.5cm][below right=of s_2](s_6){};
   	\node[state, minimum size=0.5cm][below=1.06cm of s_3](s_7){};
   	\node[state, minimum size=0.5cm][below left=of s_4](s_8){};
	\node[state, minimum size=0.5cm][below right=of s_4,fill=red](s_9){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_5](s_10){};
	\node[state, minimum size=0.5cm][below left=1.7cm of s_7](s_11){};
	\node[state, minimum size=0.5cm][below right=1.7cm of s_7](s_12){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_9,fill=red](s_13){};
	\node[minimum size=0.5cm][below=of s_10](s_14){$\cdots$};
	\node[minimum size=0.5cm][below=of s_6](s_15){$\cdots$};
	\node[state, minimum size=0.5cm][below=of s_11](s_16){};
	\node[minimum size=0.5cm][below=of s_12](s_17){$\cdots$};
	\node[minimum size=0.5cm][below=of s_8](s_18){$\cdots$};
	\node[state,minimum size=0.5cm][below=of s_13](s_19){};
	\node[state,minimum size=0.5cm][below left=2.12cm of s_13,fill=blue](s_20){};
	\node[state,minimum size=0.5cm][below right=2.12cm of s_13](s_21){};
	\node[minimum size=0.5cm][below=of s_16](s_22){$\cdots$};
	\node[minimum size=0.5cm][below=of s_19](s_23){$\cdots$};
	\node[minimum size=0.5cm][below=of s_20](s_24){$\cdots$};
	\node[minimum size=0.5cm][below=of s_21](s_25){$\cdots$};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge node {} (s_2)
    	edge node {} (s_3)
    	edge node {} (s_4)
    (s_2) edge node {} (s_5)
    	edge node {} (s_6)
    (s_3) edge node {} (s_7)
    (s_4) edge node {} (s_8)
    	edge node {} (s_9)
    (s_5) edge node {} (s_10)
    (s_7) edge node {} (s_11)
    	edge node {} (s_12)
    (s_9) edge node {} (s_13)
    (s_11) edge node {} (s_16)
    (s_13) edge node {} (s_19)
    	edge node {} (s_20)
    	edge node {} (s_21);
\end{tikzpicture}
}\\
$M,s_0\models E$\color{red}q$\;U\;$\color{blue}p
\end{center}

\begin{center}
\resizebox{10cm}{!}{
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,on grid,auto] 
   	\node[state,initial,minimum size=0.5cm](s_1){}; 
   	\node[state, minimum size=0.5cm][below=of s_1](s_3){};
   	\node[state, minimum size=0.5cm][left=4cm of s_3](s_2){};
   	\node[state, minimum size=0.5cm][right=4cm of s_3](s_4){};
   	\node[state, minimum size=0.5cm][below left=of s_2](s_5){};
   	\node[state, minimum size=0.5cm][below right=of s_2,fill=red](s_6){};
   	\node[state, minimum size=0.5cm][below=1.06cm of s_3](s_7){};
   	\node[state, minimum size=0.5cm][below left=of s_4](s_8){};
	\node[state, minimum size=0.5cm][below right=of s_4](s_9){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_5](s_10){};
	\node[state, minimum size=0.5cm][below left=1.7cm of s_7](s_11){};
	\node[state, minimum size=0.5cm][below right=1.7cm of s_7](s_12){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_9](s_13){};
	\node[minimum size=0.5cm][below=of s_10](s_14){$\cdots$};
	\node[minimum size=0.5cm][below=of s_6](s_15){$\cdots$};
	\node[state, minimum size=0.5cm][below=of s_11](s_16){};
	\node[minimum size=0.5cm][below=of s_12](s_17){$\cdots$};
	\node[minimum size=0.5cm][below=of s_8](s_18){$\cdots$};
	\node[state,minimum size=0.5cm][below=of s_13](s_19){};
	\node[state,minimum size=0.5cm][below left=2.12cm of s_13](s_20){};
	\node[state,minimum size=0.5cm][below right=2.12cm of s_13](s_21){};
	\node[minimum size=0.5cm][below=of s_16](s_22){$\cdots$};
	\node[minimum size=0.5cm][below=of s_19](s_23){$\cdots$};
	\node[minimum size=0.5cm][below=of s_20](s_24){$\cdots$};
	\node[minimum size=0.5cm][below=of s_21](s_25){$\cdots$};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge node {} (s_2)
    	edge node {} (s_3)
    	edge node {} (s_4)
    (s_2) edge node {} (s_5)
    	edge node {} (s_6)
    (s_3) edge node {} (s_7)
    (s_4) edge node {} (s_8)
    	edge node {} (s_9)
    (s_5) edge node {} (s_10)
    (s_7) edge node {} (s_11)
    	edge node {} (s_12)
    (s_9) edge node {} (s_13)
    (s_11) edge node {} (s_16)
    (s_13) edge node {} (s_19)
    	edge node {} (s_20)
    	edge node {} (s_21);
\end{tikzpicture}
}\\
$M,s_0\models EF$\color{red}p
\end{center}

\begin{center}
\resizebox{10cm}{!}{
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,on grid,auto] 
   	\node[state,initial,minimum size=0.5cm](s_1){}; 
   	\node[state, minimum size=0.5cm][below=of s_1,fill=red](s_3){};
   	\node[state, minimum size=0.5cm][left=4cm of s_3,fill=red](s_2){};
   	\node[state, minimum size=0.5cm][right=4cm of s_3,fill=red](s_4){};
   	\node[state, minimum size=0.5cm][below left=of s_2](s_5){};
   	\node[state, minimum size=0.5cm][below right=of s_2](s_6){};
   	\node[state, minimum size=0.5cm][below=1.06cm of s_3](s_7){};
   	\node[state, minimum size=0.5cm][below left=of s_4](s_8){};
	\node[state, minimum size=0.5cm][below right=of s_4](s_9){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_5](s_10){};
	\node[state, minimum size=0.5cm][below left=1.7cm of s_7](s_11){};
	\node[state, minimum size=0.5cm][below right=1.7cm of s_7](s_12){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_9](s_13){};
	\node[minimum size=0.5cm][below=of s_10](s_14){$\cdots$};
	\node[minimum size=0.5cm][below=of s_6](s_15){$\cdots$};
	\node[state, minimum size=0.5cm][below=of s_11](s_16){};
	\node[minimum size=0.5cm][below=of s_12](s_17){$\cdots$};
	\node[minimum size=0.5cm][below=of s_8](s_18){$\cdots$};
	\node[state,minimum size=0.5cm][below=of s_13](s_19){};
	\node[state,minimum size=0.5cm][below left=2.12cm of s_13](s_20){};
	\node[state,minimum size=0.5cm][below right=2.12cm of s_13](s_21){};
	\node[minimum size=0.5cm][below=of s_16](s_22){$\cdots$};
	\node[minimum size=0.5cm][below=of s_19](s_23){$\cdots$};
	\node[minimum size=0.5cm][below=of s_20](s_24){$\cdots$};
	\node[minimum size=0.5cm][below=of s_21](s_25){$\cdots$};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge node {} (s_2)
    	edge node {} (s_3)
    	edge node {} (s_4)
    (s_2) edge node {} (s_5)
    	edge node {} (s_6)
    (s_3) edge node {} (s_7)
    (s_4) edge node {} (s_8)
    	edge node {} (s_9)
    (s_5) edge node {} (s_10)
    (s_7) edge node {} (s_11)
    	edge node {} (s_12)
    (s_9) edge node {} (s_13)
    (s_11) edge node {} (s_16)
    (s_13) edge node {} (s_19)
    	edge node {} (s_20)
    	edge node {} (s_21);
\end{tikzpicture}
}\\
$M,s_0\models AX$\color{red}p
\end{center}

\begin{center}
\resizebox{10cm}{!}{
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,on grid,auto] 
   	\node[state,initial,minimum size=0.5cm,fill=red](s_1){}; 
   	\node[state, minimum size=0.5cm][below=of s_1,fill=red](s_3){};
   	\node[state, minimum size=0.5cm][left=4cm of s_3,fill=red](s_2){};
   	\node[state, minimum size=0.5cm][right=4cm of s_3,fill=red](s_4){};
   	\node[state, minimum size=0.5cm][below left=of s_2,fill=red](s_5){};
   	\node[state, minimum size=0.5cm][below right=of s_2,fill=red](s_6){};
   	\node[state, minimum size=0.5cm][below=1.06cm of s_3,fill=red](s_7){};
   	\node[state, minimum size=0.5cm][below left=of s_4,fill=red](s_8){};
	\node[state, minimum size=0.5cm][below right=of s_4,fill=red](s_9){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_5,fill=red](s_10){};
	\node[state, minimum size=0.5cm][below left=1.7cm of s_7,fill=red](s_11){};
	\node[state, minimum size=0.5cm][below right=1.7cm of s_7,fill=red](s_12){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_9,fill=red](s_13){};
	\node[minimum size=0.5cm][below=of s_10](s_14){$\cdots$};
	\node[minimum size=0.5cm][below=of s_6](s_15){$\cdots$};
	\node[state, minimum size=0.5cm][below=of s_11,fill=red](s_16){};
	\node[minimum size=0.5cm][below=of s_12](s_17){$\cdots$};
	\node[minimum size=0.5cm][below=of s_8](s_18){$\cdots$};
	\node[state,minimum size=0.5cm][below=of s_13,fill=red](s_19){};
	\node[state,minimum size=0.5cm][below left=2.12cm of s_13,fill=red](s_20){};
	\node[state,minimum size=0.5cm][below right=2.12cm of s_13,fill=red](s_21){};
	\node[minimum size=0.5cm][below=of s_16](s_22){$\cdots$};
	\node[minimum size=0.5cm][below=of s_19](s_23){$\cdots$};
	\node[minimum size=0.5cm][below=of s_20](s_24){$\cdots$};
	\node[minimum size=0.5cm][below=of s_21](s_25){$\cdots$};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge node {} (s_2)
    	edge node {} (s_3)
    	edge node {} (s_4)
    (s_2) edge node {} (s_5)
    	edge node {} (s_6)
    (s_3) edge node {} (s_7)
    (s_4) edge node {} (s_8)
    	edge node {} (s_9)
    (s_5) edge node {} (s_10)
    (s_7) edge node {} (s_11)
    	edge node {} (s_12)
    (s_9) edge node {} (s_13)
    (s_11) edge node {} (s_16)
    (s_13) edge node {} (s_19)
    	edge node {} (s_20)
    	edge node {} (s_21);
\end{tikzpicture}
}\\
$M,s_0\models AG$\color{red}p
\end{center}

\begin{center}
\resizebox{10cm}{!}{
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,on grid,auto] 
   	\node[state,initial,minimum size=0.5cm](s_1){}; 
   	\node[state, minimum size=0.5cm][below=of s_1](s_3){};
   	\node[state, minimum size=0.5cm][left=4cm of s_3](s_2){};
   	\node[state, minimum size=0.5cm][right=4cm of s_3](s_4){};
   	\node[state, minimum size=0.5cm][below left=of s_2](s_5){};
   	\node[state, minimum size=0.5cm][below right=of s_2,fill=red](s_6){};
   	\node[state, minimum size=0.5cm][below=1.06cm of s_3](s_7){};
   	\node[state, minimum size=0.5cm][below left=of s_4,fill=red](s_8){};
	\node[state, minimum size=0.5cm][below right=of s_4](s_9){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_5,fill=red](s_10){};
	\node[state, minimum size=0.5cm][below left=1.7cm of s_7](s_11){};
	\node[state, minimum size=0.5cm][below right=1.7cm of s_7,fill=red](s_12){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_9,fill=red](s_13){};
	\node[minimum size=0.5cm][below=of s_10](s_14){$\cdots$};
	\node[minimum size=0.5cm][below=of s_6](s_15){$\cdots$};
	\node[state, minimum size=0.5cm][below=of s_11,fill=red](s_16){};
	\node[minimum size=0.5cm][below=of s_12](s_17){$\cdots$};
	\node[minimum size=0.5cm][below=of s_8](s_18){$\cdots$};
	\node[state,minimum size=0.5cm][below=of s_13](s_19){};
	\node[state,minimum size=0.5cm][below left=2.12cm of s_13](s_20){};
	\node[state,minimum size=0.5cm][below right=2.12cm of s_13](s_21){};
	\node[minimum size=0.5cm][below=of s_16](s_22){$\cdots$};
	\node[minimum size=0.5cm][below=of s_19](s_23){$\cdots$};
	\node[minimum size=0.5cm][below=of s_20](s_24){$\cdots$};
	\node[minimum size=0.5cm][below=of s_21](s_25){$\cdots$};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge node {} (s_2)
    	edge node {} (s_3)
    	edge node {} (s_4)
    (s_2) edge node {} (s_5)
    	edge node {} (s_6)
    (s_3) edge node {} (s_7)
    (s_4) edge node {} (s_8)
    	edge node {} (s_9)
    (s_5) edge node {} (s_10)
    (s_7) edge node {} (s_11)
    	edge node {} (s_12)
    (s_9) edge node {} (s_13)
    (s_11) edge node {} (s_16)
    (s_13) edge node {} (s_19)
    	edge node {} (s_20)
    	edge node {} (s_21);
\end{tikzpicture}
}\\
$M,s_0\models AF$\color{red}p
\end{center}

\begin{center}
\resizebox{10cm}{!}{
\begin{tikzpicture}[shorten >=1pt,node distance=1.5cm,on grid,auto] 
   	\node[state,initial,minimum size=0.5cm,fill=red](s_1){}; 
   	\node[state, minimum size=0.5cm][below=of s_1,fill=red](s_3){};
   	\node[state, minimum size=0.5cm][left=4cm of s_3,fill=red](s_2){};
   	\node[state, minimum size=0.5cm][right=4cm of s_3,fill=red](s_4){};
   	\node[state, minimum size=0.5cm][below left=of s_2,fill=red](s_5){};
   	\node[state, minimum size=0.5cm][below right=of s_2,fill=blue](s_6){};
   	\node[state, minimum size=0.5cm][below=1.06cm of s_3,fill=red](s_7){};
   	\node[state, minimum size=0.5cm][below left=of s_4,fill=blue](s_8){};
	\node[state, minimum size=0.5cm][below right=of s_4,fill=red](s_9){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_5,fill=blue](s_10){};
	\node[state, minimum size=0.5cm][below left=1.7cm of s_7,fill=red](s_11){};
	\node[state, minimum size=0.5cm][below right=1.7cm of s_7,fill=blue](s_12){};
	\node[state, minimum size=0.5cm][below=1.2cm of s_9,fill=blue](s_13){};
	\node[minimum size=0.5cm][below=of s_10](s_14){$\cdots$};
	\node[minimum size=0.5cm][below=of s_6](s_15){$\cdots$};
	\node[state, minimum size=0.5cm][below=of s_11,fill=blue](s_16){};
	\node[minimum size=0.5cm][below=of s_12](s_17){$\cdots$};
	\node[minimum size=0.5cm][below=of s_8](s_18){$\cdots$};
	\node[state,minimum size=0.5cm][below=of s_13](s_19){};
	\node[state,minimum size=0.5cm][below left=2.12cm of s_13](s_20){};
	\node[state,minimum size=0.5cm][below right=2.12cm of s_13](s_21){};
	\node[minimum size=0.5cm][below=of s_16](s_22){$\cdots$};
	\node[minimum size=0.5cm][below=of s_19](s_23){$\cdots$};
	\node[minimum size=0.5cm][below=of s_20](s_24){$\cdots$};
	\node[minimum size=0.5cm][below=of s_21](s_25){$\cdots$};
    \path[-{>[scale=2,length=3,width=3]}] 
    (s_1) edge node {} (s_2)
    	edge node {} (s_3)
    	edge node {} (s_4)
    (s_2) edge node {} (s_5)
    	edge node {} (s_6)
    (s_3) edge node {} (s_7)
    (s_4) edge node {} (s_8)
    	edge node {} (s_9)
    (s_5) edge node {} (s_10)
    (s_7) edge node {} (s_11)
    	edge node {} (s_12)
    (s_9) edge node {} (s_13)
    (s_11) edge node {} (s_16)
    (s_13) edge node {} (s_19)
    	edge node {} (s_20)
    	edge node {} (s_21);
\end{tikzpicture}
}\\
$M,s_0\models A$\color{red}q$\;U\;$\color{blue}p
\end{center}

\subsection{Kiểm tra mô hình với NuSMV}

\hspace{0.5cm}Công cụ kiểm tra mô hình NuSMV được sử dụng để kiểm tra một mô hình có thoã mãn tính chất cần được kiểm tra hay không. Trong đó, mô hình cần kiểm tra sẽ được chuyển đổi qua mô hình NuSMV sử dụng ngôn ngữ SMV và tính chất cần được mô tả hình thức dưới dạng biểu thức logic CTL hoặc LTL.\\

\hspace{0.5cm}Ví dụ \ref {lst:NuSMVSample} sẽ trình bày cú pháp đơn giản để xây dựng một mô hình NuSMV, qua đó chuyển đổi một mô hình cơ bản quá trình thực thi của một tập tin tương ứng với mô hình \ref {lst:SampleExeASM} đã được trình bày ở trên, dưới dạng mô hình NuSMV. Cũng như sẽ mô tả một tính chất đơn giản để thực hiện việc kiểm tra trên mô hình này, giả sử tính chất cần được kiểm tra là: "Tồn tại một câu lệnh push một giá trị bất kì vào stack trong quá trình thực thi."

\begin{code}
\begin{lstlisting}[captionpos=b,caption={Ví dụ về kiểm tra mô hình trên NuSMV},label={lst:NuSMVSample},frame=single]
MODULE operand2(addr)
VAR
  op:{eax, undefined}
ASSIGN
  init(op):=undefined;
  next(op):=
    case
      (addr=0x00401000):eax;
      (addr=0x00401005):undefined;
      (addr=0x00401007):{eax, undefined};
      TRUE: undefined;
    esac;

MODULE operand1(addr)
VAR
  op:{0x00401007, eax, 0x00401005, ss:[esp], undefined}
ASSIGN
  init(op):=0x00401007;
  next(op):=
    case
      (addr=0x00401000):eax;
      (addr=0x00401005):0x00401005;
      (addr=0x00401007):{ss[esp], eax};
      TRUE: undefined;
    esac;

MODULE mnemonic(addr)
VAR
  mnem:{pushl, xorl, jne, movl, undefined}
ASSIGN
  init(mnem):=pushl;
  next(mnem):=
    case
      (addr=0x00401000):xor;
      (addr=0x00401005):jne;
      (addr=0x00401007):{call,xor};
      TRUE: undefined;
    esac;

MODULE state
VAR
  addr:{0x00401000,0x00401005,0x00401007,0x0040100B};
  mnem:mnemonic(addr);
  op1:operand1(addr);
  op2:operand2(addr);
ASSIGN
  init(addr):=0x00401000;
  next(addr):=
    case
      (addr=0x00401000):0x00401005;
      (addr=0x00401005):0x00401007;
      (addr=0x00401007):{0x0040100B,0x00401005};
      TRUE: addr;
    esac;

MODULE main
VAR
  s: state;

CTLSPEC AF(s.mnem == pushl)

\end{lstlisting}
\end{code}

\section{Các kỹ thuật chính của Packer}

\hspace{0.5cm}Hiện tại, hệ thống BE-PUM đã phân tích hoàn toàn được 27 packer. Các kỹ thuật trong 27 packer này được chia thành 6 nhóm bao gồm:

\begin{itemize}
\item{Code placing obfuscation: Dynamic Code và Code layout}
\item{Self-Modification: Dynamic Code, Code Overwriting, Overlapping Block}
\item{Instruction Obfuscation: Indirect Jump}
\item{Anti-tracing: Structured Exception Handler và 2 Special APIs}
\item{Arithmetic Operation: Obfuscated Constants và Checksumming}
\item{Anti-tampering: Checksumming, Anti-reversing, Anti-rewriting}
\end{itemize}

\subsection{Code placing obfuscation}\label{subsec:Packer1Tech}
\hspace{0.5cm}Nhóm kỹ thuật Code Placing Obfuscation bao gồm 2 nhóm kỹ thuật chính là: Dynamic Code và Code Layout.
\begin{enumerate}
\item{\textbf{Dynamic Code}: nhóm kỹ thuật Dynamic Code được sử dụng trong packer dưới dạng 2 kỹ thuật chính là Code Overwriting và kỹ thuật Packing/Unpacking.  
\begin{itemize}
\item{Kỹ thuật Code Overwriting: kỹ thuật này còn được gọi là kỹ thuật Self-modifying Code (SMC). Theo đó, packer sẽ sử dụng kỹ thuật này để có thể thay đổi động mã nhị phân của chương trình trong quá trình thực thi, chính vì giá trị này hay giá trị opcode thay đổi dẫn đến câu lệnh tại địa chỉ đó cũng được thay đổi. Packer sử dụng kỹ thuật này để có thể thay đổi chữ ký của mình vì thế đối với những phần mềm chống malware nhận dạng packer thông qua chữ ký sẽ không thể nhận dạng được vì chữ ký này luôn thay đổi liên tục. Chính vì hệ thống BE-PUM hỗ trợ giải thuật On-the-fly model generation với khả năng xử lý những thay động trong mã nhị phân mà hệ thống BE-PUM dễ dàng xử lý được kỹ thuật này. Đoạn mã \ref {lst:SMCinYODA} mô tả kỹ thuật Code Overwriting được sử dụng trong packer YODA. Theo đó sau khi thực thi đoạn mã tại vị trí 0x004040C6 với giá trị EDI = 0x004040C6, câu lệnh CMP đã được thay đổi thành câu lệnh MOV. 
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật Code Overwriting sử dụng trong packer YODA},label={lst:SMCinYODA},frame=single]
004040C3	stos es:[edi]
004040C6	cmp ecx, ebp

004040C3	stos es:[edi]
004040C6	mov ebp, ecx
\end{lstlisting}
\end{code}
}
\item{Kỹ thuật Packing/Unpacking: kỹ thuật này còn được gọi là kỹ thuật Encryption/Decryption, lõi của kỹ thuật này chính là kỹ thuật SMC đã được trình bày như trên, với số lượng vòng lặp được sử dụng để thay đổi một hoặc nhiều byte dẫn đến việc thay đổi câu lệnh liên tục trong suốt quá trình thực thi. Chính vì hệ thống BE-PUM có thể xử lý kỹ thuật SMC và hỗ trợ Dynamic symbolic execution mà giải thuật này dễ dàng được xử lý. Đoạn mã \ref {lst:PUinYODA} mô tả kỹ thuật packing/unpacking được sử dụng trong packer YODA.  
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật Packing/Unpacking sử dụng trong packer YODA},label={lst:PUinYODA},frame=single]
00404092	lods ds:[edi]
00404093	ror al, db
00404096	jmp 0x00404099
00404099	dec al
0040409B	add al,0x21
0040409D	dec al
0040409F	add al,cl
004040A1	stc
004040A2	add al,0x57
004040A4	clc
004040A5	add al,0x8A
004040A7	stc
004040A8	nop
004040A9	ror al,0xD7
004040AC	ror al,0x10
004040AF	jmp 0x004040B2
004040B2	ror al,0x5B
004040B5	clc
004040B6	xor al,0xD6
004040B8	stc
004040B9	xor al,0xD4
004040BB	sub al,cl
004040BD	jmp 0x004040C0 
004040C0	sub al,0x8B
004040C2	clc
004040C3	stos es:[edi]
004040C4	loopd 0x00404092
\end{lstlisting}
\end{code}
}
\end{itemize}
}
\item{\textbf{Code Layout}: nhóm kỹ thuật Code Layout được sử dụng trong packer dưới dạng 3 kỹ thuật chính là: Overlapping Functions, Overlapping Blocks và Code Chunking.
\begin{itemize}
\item{Kỹ thuật Overlapping Functions: kỹ thuật này với lõi là kỹ thuật Overlapping Instructions theo đó tại một địa chỉ bất kì trong phân cùng code mà có thể có rất nhiều câu lệnh mang giá trị tương ứng với các giá trị opcode khác nhau. Mỗi hàm được xác định với địa chỉ bắt đầu tại địa chỉ cũng là giá trị của toán hạng trong câu lệnh CALL và địa chỉ kết thúc chính là địa chỉ của câu lệnh RET trong cùng một hàm. Chính vì hệ thống BE-PUM hỗ trợ kỹ thuật On-the-fly nên kỹ thuật này cũng sẽ được BE-PUM xử lý không khó khăn.\\}
\item{Kỹ thuật Overlapping Blocks: kỹ thuật này cũng với lõi là kỹ thuật Overlapping Instructions. Khác với Overlapping Function mỗi khối được xác định và giới hạn thông qua câu lệnh nhảy hoặc nhảy có điều kiện. Đoạn mã \ref {lst:OBinYODA} mô tả kỹ thuật Overlapping Block được sử dụng trong packer YODA. Theo đó tại vị trí 0x004040BD một câu lệnh nhảy sẽ nhảy tới địa chỉ 0x004040C0 và tại địa chỉ này sẽ được dịch ngược thành một câu lệnh hoàn toàn khác. 
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật Overlapping Block sử dụng trong packer YODA},label={lst:OBinYODA},frame=single]
0040409D	dec al
0040409F	add al, cl
...
004040BF	retn 0x8B2C		
004040C2	clc
004040C3	stos es:[edi]
004040C4	loopd 0x00404092
00404092	lods ds:[edi]
...		
004040BD	jmp 0x004040C0
\end{lstlisting}
\end{code}
}
\item{Kỹ thuật Code Chunking: kỹ thuật này được packer sử dụng để có thể chia đoạn mã thực thi thành nhiều khối, mỗi khối là một tập với số lệnh câu lệnh xử lý rất ít hay nói cách khác mỗi khối có kích thước là dưới 20 bytes, mỗi khối này kết thúc với một câu lệnh nhảy. Hệ thống BE-PUM sử dụng kỹ thuật Dynamic symbolic execution để xử lý các câu lệnh nhảy do đó hệ thống BE-PUM cũng dễ dàng xử lý các kỹ thuật này. Đoạn mã \ref {lst:CCinYODA} mô tả kỹ thuật Code Chunking trong packer YODA, trong đó có thể thấy đoạn mã được chia nhỏ làm các khối 0x0040446E, 0x004474, 0x00404477, 0x0040447A.
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật Code Chunking sử dụng trong packer YODA},label={lst:CCinYODA},frame=single]
0040446B jmp 0x0040446E
... 
0040446E stc 
... 
00404474 jmp 0x00404477
...
00404477 jmp 0x0040447A
...
0040447A jmp 0x0040447D 
... 
0040447D nop
\end{lstlisting}
\end{code}
}
\end{itemize}
}
\end{enumerate}

\subsection{Self-Modifcation}
\hspace{0.5cm}Nhóm kỹ thuật Self-Modification bao gồm kỹ thuật Dynamic Code, Code Overwriting, Overlapping Block như đã được trình bày cụ thể trong chương \ref {subsec:Packer1Tech}, cũng như hướng xử lý những kỹ thuật này trên hệ thống BE-PUM.

\subsection{Instruction Obfuscation}
\hspace{0.5cm}Nhóm kỹ thuật Instruction Obfuscation hay còn gọi là kỹ thuật Indirect Jump, kỹ thuật được sử dụng rất nhiều trong hầu hết các packer. Theo đó, địa chỉ của câu lệnh nhảy, nhảy có điều kiện hay câu lệnh gọi hàm, và trả về của hàm được lưu trữ trong thanh ghi, bộ nhớ hay stack. Kỹ thuật Indirect Jump bao gồm 3 dạng: Indirect Call - giá trị đích được lưu trong lệnh gọi hàm CALL, Indirect Jump - giá trị đích được lưu trong lệnh nhảy hay nhảy có điều kiện, và Indirect Return - giá trị đích được xác định thông qua giá trị của thanh ghi ESP, do đó một packer sẽ thay đổi giá trị này và gọi lệnh trả về hàm để nhảy tới vị trí tại đỉnh của stack. Hệ thống BE-PUM sử dụng kỹ thuật Dynamic symbolic execution do đó hệ thống BE-PUM có thể dễ dàng xử lý được kỹ thuật này. Đoạn mã \ref {lst:IJinUPX} mô tả một ví dụ về việc sử dụng kỹ thuật Indirect Call trong packer UPX, theo đó giá trị đích nhảy đến được tính toán qua giá trị trong thanh ghi ESI.
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật Indirect Jump sử dụng trong packer UPX},label={lst:IJinUPX},frame=single]
004053FA  call ds:[esi+503C]
\end{lstlisting}
\end{code}

\subsection{Anti-tracing}
\hspace{0.5cm}Nhóm kỹ thuật Anti-tracing bao gồm 2 kỹ thuật chính là: Structured Exception Handler (SEH) và Two Special APIs.

\begin{itemize}
\item{Kỹ thuật SEH: bao gồm 2 giai đoạn chính. Trong giai đoạn đầu, packer sẽ thiết lập một ngoại lệ bằng cách sử dụng câu lệnh để có thể lưu trữ địa chỉ của hàm xử lý ngoại lệ trong thanh ghi FS:[0], giai đoạn này được gọi là Setup Exception. Khi một ngoại lệ xảy ra do thực hiện câu lệnh chia cho 0, đọc hoặc ghi vào vùng bộ nhớ không hợp lệ, hoặc khi Trap Flag được thiết lập giá trị FALSE, và khi packer cố tình sử dụng những câu lệnh ngắt như: INT3, INT68,...hệ thống khi đó sẽ tự động chuyển qua hàm xử lý ngoại lệ, giai đoạn này được gọi là Causing Exception. BE-PUM giải quyết vấn đề xử lý SEH bằng cách giả lập thanh ghi FS chứa giá trị địa chỉ của hàm xử lý ngoại lệ và lưu trữ danh sách các hàm xử lý ngoại lệ này. Ngoài ra, để kiểm tra ngoại lệ, BE-PUM kiểm tra câu lệnh là hợp lệ hay không, nếu không sẽ thực hiện chuyển đổi ngữ cảnh stack để thực hiện xử lý ngoại lệ, chính vì thế BE-PUM có thể dễ dàng xử lý được kỹ thuật này. Đoạn mã \ref {lst:SEHinPETITE} mô tả một ví dụ về việc sử dụng kỹ thuật SEH trong packer PETITE, theo đó có thể thấy 2 giai đoạn: Setup Exception tại vị trí 0x00404122 và Causing Exception tại vị trí 0x0040421E.
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật SEH sử dụng trong packer PETITE},label={lst:SEHinPETITE},frame=single]
00404116  push 0x004022E3
0040411B  push fs:[0]
00404122  mov fs:[0], esp
...
0040421E  mov ds:[edi],al
\end{lstlisting}
\end{code}
}
\item{Kỹ thuật Two Special APIs: trong kỹ thuật này, packer sẽ không nạp tất cả API cần sử dụng mà thay vào đó, packer sẽ chỉ nạp 2 API đặc biệt là: LoadLibrary và GetProcAddress để có thể lấy được địa chỉ của các API sẽ sử dụng. Hệ thống BE-PUM đã hỗ trợ 2 API đặc biệt này nên dễ dàng xử lý kỹ thuật.
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật Two Special APIs sử dụng trong packer FSG},label={lst:TwoAPIinFSG},frame=single]
004001C5  push eax
004001C6  call kernel32.LoadLibrary
...
004001D4  push eax
004001D5  push ebp
004001D6  call kernel32.GetProcAddress
\end{lstlisting}
\end{code}
}
\end{itemize}

\subsection{Arithmetic Operation}\label{subsec:Packer5Tech}
\hspace{0.5cm}Nhóm kỹ thuật Arithmetic Operation bao gồm 2 kỹ thuật chính bao gồm: Obfuscated Constants và Checksumming.

\begin{itemize}
\item{Kỹ thuật Obfuscated Constants: trong kỹ thuật này, thay vào việc sử dụng trực tiếp một gía trị hằng số, hay một số giá trị hexa cụ thể thì packer sẽ sử dụng rất nhiều câu lệnh tính toán phức tạp nhưng vẫn cho ra một hằng số mong muốn. Mục đích cụ thể là nâng cao độ phức tạp trong tính toán và làm rối rắm quá trình xử lý. Hệ thống BE-PUM hiện tại hỗ trợ hơn 200 câu lệnh hợp ngữ do đó việc tính toán các câu lệnh này là khả thi, tuy sẽ còn một số hạn chế nếu như packer sử dụng những câu lệnh tính toán mà hệ thống BE-PUM chưa hỗ trợ. Đoạn mã \ref {lst:OCinTELOCK} cho thấy quá trình sử dụng những câu lệnh XOR và SUB để tính toán một giá trị hằng số và được lưu trong thanh ghi EAX. 
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật Obfuscated Constants sử dụng trong packer TELOCK},label={lst:OCinTELOCK},frame=single]
00404C4B  mov eax, ss:[ebp + 40D280] 
00404C51  push eax
00404C52  xor eax, 7DCC805B 
00404C57  sub eax, 2A5DA2BD
\end{lstlisting}
\end{code}
}
\item{Kỹ thuật Checksumming: còn gọi là kỹ thuật CRC Checking, kỹ thuật này bao gồm 2 giai đoạn chính. Trong giai đoạn đầu, packer sẽ tính toán giá trị checksum với các giá trị xác định trong bộ nhớ, việc tính toán sẽ được tính toán qua các rất nhiều câu lệnh phức tạp cùng với số lần lặp là rất lớn. Trong giai đoạn tiếp theo, packer sẽ sử dụng một câu lệnh so sánh trực tiếp giá trị checksum này với một giá trị hằng số cụ thể để đảm bảo quá trình tính toán giá trị này cho ra một kết quả chính xác. Hệ thống BE-PUM hỗ trợ kỹ thuật Dynamic symbolic execution và phân tích trên giải thuật On-the-fly do đó hệ thống dễ dàng xử lý kỹ thuật này của packer. Đoạn mã \ref {lst:CSinTELOCK} biểu diễn hai quá trình của kỹ thuật Checksumming bao gồm việc tính toán giá trị checksum bắt đầu từ vị trí 0x004047F5 đến vị trí 00404806 và giai đoạn so sánh với giá trị hằng số 0x579122E6 tại vị trí 0x00404C57. 
\begin{code}
\begin{lstlisting} [captionpos=b,caption={Kỹ thuật Checksumming sử dụng trong packer TELOCK},label={lst:CSinTELOCK},frame=single]
004047F5  xor eax, eax
004047F7  lods ds:[edi]
004047F8  xor al, dl
004047FA  shr eax,0x1
00404806  inc ecx
00404812  jg 0x004047F5
...
00404C4B  mov eax, ss:[ebp + 40D280]
00404C51  push eax
00404C52  xor eax, 7DCC805B 
00404C57  sub eax, 2A5DA2BD
00404C63  jnz 0x0040527B
\end{lstlisting}
\end{code}
}
\end{itemize}

\subsection{Anti-tampering}
\hspace{0.5cm}Nhóm kỹ thuật Anti-tampering bao gồm các kỹ thuật chính: Anti-reversing, Anti-rewriting.

\begin{enumerate}
\item{\textbf{Anti-debugging}: Nhóm kỹ thuật Anti-debugging được sử dụng trong packer dưới dạng 3 kỹ thuật chính: Timming Check, Hardware Breakpoints, Anti-debugging.
\begin{itemize}
\item{Kỹ thuật Timing Check: trong kỹ thuật này, packer sẽ sử dụng những API có liên quan đến việc tính toán thời gian của hệ thống như: GetTickCount, GetSystemTime, GetLocalTime,...và những câu lệnh đặc biệt như RDTSC. Trong quá trình thực thi bình thường giá trị thời gian sẽ được tính toán bằng một hằng số cụ thể nhưng nếu tiến trình được xử lý trong môi trường debugger giá trị này sẽ được tính toán khác đi, do đó packer sẽ dễ dàng nhận dạng và kết thúc mở gói. Hệ thống BE-PUM đang dần mở rộng và hiện tại đã hỗ trợ hơn 400 API cũng như hỗ trợ nhiều hơn với các câu lệnh hợp ngữ do đó cũng sẽ xử lý được kỹ thuật này. Tuy nhiên sự tinh vi trong việc sử dụng này bằng cách sử dụng những API phức tạp hơn cũng chính là hạn chế mà hệ thống BE-PUM sẽ được mở rộng để hỗ trợ tốt hơn. Đoạn mã \ref {lst:TCinPECOMPACT} mô tả việc sử dụng API GetTickCount để lấy giá trị thời gian của hệ điều hành.
\begin{code}
\begin{lstlisting} [captionpos=b,caption={Kỹ thuật Timming Check sử dụng trong packer PECOMPACT},label={lst:TCinPECOMPACT},frame=single]
00404600  xor eax, eax
00404602  call GetTickCount
00404605  cmp eax, 0
00404608  jne 0x00404620
\end{lstlisting}
\end{code}
}
\item{Kỹ thuật Hardware Breakpoints: kỹ thuật này đã được trình bày như ví dụ cụ thể trong chương \ref {subsec:Example3}. Hệ thống BE-PUM được mở rộng để hỗ trợ thêm 8 thanh ghi debug do đó hệ thống BE-PUM cũng đã xử lý được kỹ thuật này.\\}
\item{Kỹ thuật Anti-debugging: trong kỹ thuật này, packer sẽ sử dụng những API để nhận dạng nếu tiến trình đang được thực thi trong môi trường debug như: IsDebuggerPresent, CheckRemoteDebuggerPresent, NtQueryInformationProcess,  NtQuerySystemInformation và NtQueryObject. Hệ thống BE-PUM cũng đã hỗ trợ các API nên việc xử lý kỹ thuật này là khả thi. 
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật Anti-debugging sử dụng trong packer YODA},label={lst:ADinYODA},frame=single]
00404888 call kernel32.IsDebuggerPresent
\end{lstlisting}
\end{code}
}
\end{itemize}
}
\item{\textbf{Anti-rewriting}: Nhóm kỹ thuật Anti-rewriting được sử dụng trong packer dưới dạng 2 kỹ thuật chính: Checksumming và Stolen Bytes trong đó kỹ thuật Checksumming đã được trình bày cụ thể ở chương \ref {subsec:Packer5Tech}.
\begin{itemize}
\item{Kỹ thuật Stolen Bytes: trong kỹ thuật này, packer sẽ cấp phát một vùng nhớ ảo đặc biệt bằng việc sử dụng API VirtualAlloc và ghi các byte giá trị bộ nhớ, cũng như mở gói trên vùng nhớ ảo này thay vì sử dụng kỹ thuật SMC. Kết thúc quá trình xử lý này, vùng nhớ ảo này sẽ ghi trở lại vào vùng nhớ thực và tiếp tục xử lý. Hệ thống BE-PUM đã hỗ trợ API VirtualAlloc và hiện thực vùng nhớ ảo cho bộ nhớ và các thao tác dịch ngược trên vùng nhớ ảo sử dụng Jackstab do đó hệ thống BE-PUM đã có thể xử lý kỹ thuật này.
\begin{code}
\begin{lstlisting}[captionpos=b,caption={Kỹ thuật Stolen Bytes sử dụng trong packer PECOMPACT},label={lst:SBinPECOMPACT},frame=single]
00404899  push edx
0040489A  mov ebp, eax
0040489C  push 0x40
0040489E  push 0x1000
004048A3  push ds:[ebx + 4]
004048A6  push 0
...   
004048AF  call kernel32.VirtualAlloc
\end{lstlisting}
\end{code}
}
\end{itemize}
}
\end{enumerate}

